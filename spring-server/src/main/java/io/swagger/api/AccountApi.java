/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.8).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package io.swagger.api;

import io.swagger.model.RequestSetAccount;
import io.swagger.model.ResultSetAccount;
import io.swagger.model.ResultSetAccounts;
import io.swagger.model.ResultSetCount;
import io.swagger.model.ResultSetError;
import io.swagger.model.ResultSetOk;
import java.util.UUID;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2019-09-06T13:08:35.508Z")

@Api(value = "account", description = "the account API")
public interface AccountApi {

    @ApiOperation(value = "deleteAccount", nickname = "accountBscsAccountByStatusAndReleaseDelete", notes = "Most selective access to single row. The primary key is used. One record is returnd. The status and release must be given a priori. Only records in W like Working status may be manipulatd this way. Only records in W like Working status may be manipulatd this way.   Requires: - Booker role.", response = ResultSetCount.class, tags={ "account", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetCount.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/account/{status}/{release}/{bscsAccount}",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.DELETE)
    ResponseEntity<ResultSetCount> accountBscsAccountByStatusAndReleaseDelete(@ApiParam(value = "status of the package, W for work P for production",required=true, allowableValues = "\"W\", \"C\", \"P\"") @PathVariable("status") String status,@ApiParam(value = "release sequential number, 0 for work, else production or last",required=true, allowableValues = "\"0\", \"last\"") @PathVariable("release") String release,@ApiParam(value = "BSCS account number",required=true) @PathVariable("bscsAccount") String bscsAccount,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "updateAccount", nickname = "accountBscsAccountByStatusAndReleasePut", notes = "Most selective access to single row. The primary key is used. One record is returnd. The status and release must be given a priori. Promotion from status value W like Working to C like Controlled may be done only with Controll role.  Requires:    - Booker role while in W like Work,    - Control role while in C like Control state and in transition from W like Work to C like Control.", response = ResultSetAccounts.class, tags={ "account", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetAccounts.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/account/{status}/{release}/{bscsAccount}",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.PUT)
    ResponseEntity<ResultSetAccounts> accountBscsAccountByStatusAndReleasePut(@ApiParam(value = "status of the package, W for workm P for production",required=true, allowableValues = "\"W\", \"C\", \"P\"") @PathVariable("status") String status,@ApiParam(value = "release sequential number, 0 for work, else production or last for latst version",required=true, allowableValues = "\"0\", \"last\"") @PathVariable("release") String release,@ApiParam(value = "BSCS account code",required=true) @PathVariable("bscsAccount") String bscsAccount,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "readAccountByStatusRelease", nickname = "accountByStatusAndReleaseGet", notes = "A set of accouts is read and returned. The criteria is per status and version. The varsion must be known a priori. For work version release is always 0.", response = ResultSetAccounts.class, tags={ "account", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetAccounts.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/account/{status}/{release}",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.GET)
    ResponseEntity<ResultSetAccounts> accountByStatusAndReleaseGet(@ApiParam(value = "status of the package, W for workm P for production",required=true, allowableValues = "\"W\", \"C\", \"P\"") @PathVariable("status") String status,@ApiParam(value = "release sequential number, 0 for work, else production",required=true, allowableValues = "\"0\", \"last\"") @PathVariable("release") String release,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "deleteAccountsAll", nickname = "accountDelete", notes = "Unselective purge of the table. Used before bulk load.  Requires: - Admin role.", response = ResultSetCount.class, tags={ "account", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetCount.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/account",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.DELETE)
    ResponseEntity<ResultSetCount> accountDelete(@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "createAccount", nickname = "accountPost", notes = "A new mapping is created in W like Working status. Attempts to create item in any other status will be errored out.   Requires: - Booker role.", response = ResultSetAccount.class, tags={ "account", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetAccount.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/account",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity<ResultSetAccount> accountPost(@ApiParam(value = "Creation of object Account" ,required=true )  @Valid @RequestBody RequestSetAccount body,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "doRelease", nickname = "accountReleasePost", notes = "Does a release of version in state C like Controlled to P like Production. The impact is on Account and Order entries. Existence of not controled entries with status W like Working causes failure. Other validation rules are applied as well, for example valid date check: it must be rounded down and in the future and no clash with entries in status P like Production found in Account or Order backednd tables.   Requires: - Control role.", response = ResultSetOk.class, tags={ "account", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetOk.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/account/release",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity<ResultSetOk> accountReleasePost(@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);

}
