/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.8).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package io.swagger.api;

import io.swagger.model.RequestSetOrder;
import io.swagger.model.ResultSetCount;
import io.swagger.model.ResultSetError;
import io.swagger.model.ResultSetOrder;
import io.swagger.model.ResultSetOrders;
import java.util.UUID;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2019-09-06T13:08:35.508Z")

@Api(value = "order", description = "the order API")
public interface OrderApi {

    @ApiOperation(value = "deleteOrder", nickname = "orderBscsAccountSegmentByStatusAndReleaseDelete", notes = "Most selective access to single row. The primary key is used. One record is deleted. Only records in W like Working status may be manipulatd this way.   Requires: - Control role.", response = ResultSetCount.class, tags={ "order", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetCount.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/order/{status}/{release}/{bscsAccount}/{segment}",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.DELETE)
    ResponseEntity<ResultSetCount> orderBscsAccountSegmentByStatusAndReleaseDelete(@ApiParam(value = "status of the package, W for workm P for production",required=true, allowableValues = "\"W\", \"C\", \"P\"") @PathVariable("status") String status,@ApiParam(value = "release sequential number, 0 for work, else production",required=true, allowableValues = "\"0\", \"last\"") @PathVariable("release") String release,@ApiParam(value = "release sequential number, 0 for work, else production",required=true) @PathVariable("bscsAccount") String bscsAccount,@ApiParam(value = "customer segment code",required=true) @PathVariable("segment") String segment,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "updateOrder", nickname = "orderBscsAccountSegmentByStatusAndReleasePut", notes = "Most selective access to single row. The primary key is used. One record is returnd. The status and release must be given a priori. Only records in W like Working status may be manipulatd this way.", response = ResultSetOrders.class, tags={ "order", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetOrders.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/order/{status}/{release}/{bscsAccount}/{segment}",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.PUT)
    ResponseEntity<ResultSetOrders> orderBscsAccountSegmentByStatusAndReleasePut(@ApiParam(value = "status of the package, W for workm P for production",required=true, allowableValues = "\"W\", \"C\", \"P\"") @PathVariable("status") String status,@ApiParam(value = "release sequential number, 0 for work, else production",required=true, allowableValues = "\"0\", \"last\"") @PathVariable("release") String release,@ApiParam(value = "release sequential number, 0 for work, else production",required=true) @PathVariable("bscsAccount") String bscsAccount,@ApiParam(value = "customer segment code",required=true) @PathVariable("segment") String segment,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "readOrderByStatusRelease", nickname = "orderByStatusAndReleaseGet", notes = "Set of orders is read and returned. The criteria is per status and version. The varsion must be known a priori. For work version release is always 0.", response = ResultSetOrders.class, tags={ "order", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetOrders.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/order/{status}/{release}",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.GET)
    ResponseEntity<ResultSetOrders> orderByStatusAndReleaseGet(@ApiParam(value = "status of the package, W for workm P for production",required=true, allowableValues = "\"W\", \"C\", \"P\"") @PathVariable("status") String status,@ApiParam(value = "release sequential number, 0 for work, else production",required=true, allowableValues = "\"0\", \"last\"") @PathVariable("release") String release,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "deleteOrdersAll", nickname = "orderDelete", notes = "Unselective purge of the table. Used in bulk load.   Requires: - Admin role.", response = ResultSetCount.class, tags={ "order", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetCount.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/order",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.DELETE)
    ResponseEntity<ResultSetCount> orderDelete(@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);


    @ApiOperation(value = "createOrder", nickname = "orderPost", notes = "A new mapping is created in working status, unconfirmed. The entries segment value must be validated with values from dictionary Segment.  Requires: - Control role.", response = ResultSetOrder.class, tags={ "order", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Successful operation", response = ResultSetOrder.class),
        @ApiResponse(code = 401, message = "Not authenticated", response = ResultSetError.class),
        @ApiResponse(code = 200, message = "Server error", response = ResultSetError.class) })
    @RequestMapping(value = "/order",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity<ResultSetOrder> orderPost(@ApiParam(value = "Creation of object Order" ,required=true )  @Valid @RequestBody RequestSetOrder body,@ApiParam(value = "" ) @RequestHeader(value="X-Request-ID", required=false) UUID xRequestID);

}
